import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare let self: ServiceWorkerGlobalScope;

// ---------------------------------------------------------------------------
// 1. Precaching & Cleanup
// ---------------------------------------------------------------------------

// Cleanup caches from previous versions that are no longer needed
cleanupOutdatedCaches();

// Precache all assets generated by the build process
// This includes index.html, JS bundles, and CSS
precacheAndRoute(self.__WB_MANIFEST);

// ---------------------------------------------------------------------------
// 2. Navigation Handling (SPA)
// ---------------------------------------------------------------------------

// Handle navigation requests (SPA support)
// We use a NetworkFirst strategy for the main document so we always try to get
// the latest index.html from the server (for new deployments), but fallback
// to the cached version if offline.
const navigationRoute = new NavigationRoute(
  new NetworkFirst({
    cacheName: 'pages',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  }),
);
registerRoute(navigationRoute);

// ---------------------------------------------------------------------------
// 3. Asset Caching Strategies
// ---------------------------------------------------------------------------

// CSS, JS, and Workers: StaleWhileRevalidate
// Serve cached content immediately for performance, update in background
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: 'assets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  }),
);

// Images: CacheFirst
// Images rarely change, so cache them for a long time (30 days)
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  }),
);

// Google Fonts: CacheFirst
// Cache for 1 year
registerRoute(
  ({ url }) =>
    url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 Year
      }),
    ],
  }),
);

// ---------------------------------------------------------------------------
// 4. API Caching
// ---------------------------------------------------------------------------

// Static Reference Data (e.g., Modalities, Configuration): StaleWhileRevalidate
// Checks for updates in background but shows cached data instantly
registerRoute(
  ({ url }) =>
    url.pathname.includes('/api/config') || url.pathname.includes('/api/metadata/modalities'),
  new StaleWhileRevalidate({
    cacheName: 'api-static-data',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 Days
      }),
    ],
  }),
);

// PACS Studies List: NetworkFirst
// Critical to get fresh data, but fallback to cache if offline
registerRoute(
  ({ url }) => url.pathname.includes('/api/pacs/studies'),
  new NetworkFirst({
    cacheName: 'api-studies',
    networkTimeoutSeconds: 3, // Fallback to cache if network is slow (>3s)
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }),
);

// ---------------------------------------------------------------------------
// 5. Background Sync (Offline Actions)
// ---------------------------------------------------------------------------

// Upload Queue Plugin
const uploadQueuePlugin = new BackgroundSyncPlugin('upload-queue', {
  maxRetentionTime: 24 * 60, // Retry for max 24 Hours
  onSync: async ({ queue }) => {
    try {
      await queue.replayRequests();
      // We could broadcast a message to the client here that sync is done
    } catch (error) {
      console.error('Background sync failed:', error);
    }
  },
});

// Upload Initialization and Completion
// NOTE: These are critical calls. If offline, they queue up.
registerRoute(
  ({ url }) => url.pathname.includes('/upload/init') || url.pathname.includes('/upload/complete'),
  new NetworkOnly({
    plugins: [uploadQueuePlugin],
  }),
  'POST',
);

// Notification Read Status
// Low priority action, perfect for background sync
registerRoute(
  ({ url }) => url.pathname.includes('/api/notifications/mark-read'),
  new NetworkOnly({
    plugins: [
      new BackgroundSyncPlugin('notifications-queue', {
        maxRetentionTime: 24 * 60,
      }),
    ],
  }),
  'POST',
);

// ---------------------------------------------------------------------------
// 6. Service Worker Lifecycle
// ---------------------------------------------------------------------------

// Allow the web app to trigger skipWaiting via message
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
